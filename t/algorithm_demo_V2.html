<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>å³æ™‚æ•¸æ“šé è­¦æ¼”ç®—æ³•æ•™å­¸ï¼ˆKalmanï½œESNï½œHoltï¼‰Forecasting Algorithms Demo</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=Noto+Sans+TC:wght@300;400;500;700;900&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.umd.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.2/math.min.js"></script>
  <style>
    :root {
      --bg-primary: #0a0e1b;
      --bg-secondary: #111827;
      --bg-card: #1f2937;
      --bg-soft: #374151;
      --text-primary: #f9fafb;
      --text-secondary: #d1d5db;
      --text-muted: #9ca3af;
      --accent-primary: #3b82f6;
      --accent-secondary: #06b6d4;
      --accent-success: #10b981;
      --accent-warning: #f59e0b;
      --accent-error: #ef4444;
      --border-primary: #374151;
      --border-soft: #4b5563;
      --glass-bg: rgba(31, 41, 55, 0.8);
      --glass-border: rgba(75, 85, 99, 0.3);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      font-family: 'Inter', 'Noto Sans TC', system-ui, -apple-system, sans-serif;
      background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
      color: var(--text-primary);
      line-height: 1.6;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      min-height: 100vh;
    }

    /* Header */
    header {
      position: sticky;
      top: 0;
      z-index: 100;
      background: var(--glass-bg);
      backdrop-filter: blur(20px) saturate(1.2);
      border-bottom: 1px solid var(--glass-border);
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 1rem;
    }

    .header-content {
      display: flex;
      align-items: center;
      gap: 1rem;
      padding: 0.5rem 0;
    }

    .logo {
      width: 48px;
      height: 48px;
      border-radius: 12px;
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 900;
      font-size: 1.2rem;
      box-shadow: 0 4px 14px rgba(59, 130, 246, 0.3);
    }

    .header-text h1 {
      font-size: 1.5rem;
      font-weight: 800;
      margin-bottom: 0.25rem;
      background: linear-gradient(135deg, var(--text-primary), var(--accent-secondary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .header-text .subtitle {
      font-size: 0.875rem;
      color: var(--text-muted);
      font-weight: 500;
    }

    /* Main Grid */
    .main-grid {
      display: grid;
      gap: 1.5rem;
      margin-top: 1.5rem;
      grid-template-columns: 1fr;
    }

    @media (min-width: 1024px) {
      .main-grid {
        grid-template-columns: 1.2fr 1fr;
      }
    }

    /* Cards */
    .card {
      background: var(--bg-card);
      border: 1px solid var(--border-primary);
      border-radius: 16px;
      padding: 1.5rem;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
    }

    .card:hover {
      border-color: var(--border-soft);
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
      transform: translateY(-2px);
    }

    .card h2 {
      font-size: 1.5rem;
      font-weight: 700;
      margin-bottom: 1rem;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .card h3 {
      font-size: 1.125rem;
      font-weight: 600;
      margin-bottom: 0.75rem;
      color: var(--accent-secondary);
    }

    .card p {
      color: var(--text-secondary);
      margin-bottom: 1rem;
      line-height: 1.7;
    }

    /* Tags */
    .tag-row {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
      margin-bottom: 1.5rem;
    }

    .tag {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 0.75rem;
      background: var(--bg-soft);
      border: 1px solid var(--border-soft);
      border-radius: 999px;
      font-size: 0.875rem;
      font-weight: 500;
      color: var(--text-secondary);
      transition: all 0.2s ease;
    }

    .tag:hover {
      background: var(--accent-primary);
      color: white;
      transform: translateY(-1px);
    }

    /* Buttons */
    .btn-group {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
      margin: 1rem 0;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.75rem 1.25rem;
      border: none;
      border-radius: 12px;
      font-weight: 600;
      font-size: 0.875rem;
      cursor: pointer;
      transition: all 0.2s ease;
      text-decoration: none;
      min-height: 44px; /* Touch-friendly */
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      color: white;
      box-shadow: 0 4px 14px rgba(59, 130, 246, 0.3);
      animation: pulse-glow 2s infinite;
    }

    @keyframes pulse-glow {
      0%, 100% { box-shadow: 0 4px 14px rgba(59, 130, 246, 0.3); }
      50% { box-shadow: 0 4px 20px rgba(59, 130, 246, 0.5); }
    }

    .btn-secondary {
      background: var(--bg-soft);
      color: var(--text-primary);
      border: 1px solid var(--border-soft);
    }

    .btn-warning {
      background: linear-gradient(135deg, var(--accent-warning), #fb923c);
      color: white;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    }

    .btn:active {
      transform: translateY(0);
    }

    /* Tabs */
    .tabs {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
      background: var(--bg-secondary);
      padding: 0.25rem;
      border-radius: 12px;
      overflow-x: auto;
    }

    .tab {
      flex: 1;
      min-width: 120px;
      padding: 0.75rem 1rem;
      background: transparent;
      border: none;
      border-radius: 8px;
      color: var(--text-muted);
      font-weight: 600;
      font-size: 0.875rem;
      cursor: pointer;
      transition: all 0.2s ease;
      white-space: nowrap;
    }

    .tab.active {
      background: var(--accent-primary);
      color: white;
      box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
    }

    .tab:hover:not(.active) {
      background: var(--bg-soft);
      color: var(--text-secondary);
    }

    /* Panels */
    .panel {
      display: none;
    }

    .panel.active {
      display: block;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .panel-grid {
      display: grid;
      gap: 1.5rem;
    }

    @media (min-width: 768px) {
      .panel-grid {
        grid-template-columns: 1fr 1fr;
      }
    }

    /* Controls */
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      margin: 1rem 0;
    }

    .control {
      display: grid;
      grid-template-columns: 1fr 2fr auto;
      align-items: center;
      gap: 0.75rem;
      padding: 0.75rem;
      background: var(--bg-secondary);
      border: 1px solid var(--border-primary);
      border-radius: 8px;
    }

    .control label {
      font-weight: 500;
      font-size: 0.875rem;
      color: var(--text-primary);
    }

    .control small {
      display: block;
      color: var(--text-muted);
      font-size: 0.75rem;
      margin-top: 0.25rem;
    }

    .control input[type="range"] {
      width: 100%;
      height: 6px;
      background: var(--bg-soft);
      border-radius: 3px;
      outline: none;
      -webkit-appearance: none;
    }

    .control input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      background: var(--accent-primary);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(59, 130, 246, 0.3);
    }

    .control input[type="number"] {
      width: 80px;
      padding: 0.5rem;
      background: var(--bg-primary);
      border: 1px solid var(--border-primary);
      border-radius: 6px;
      color: var(--text-primary);
      font-size: 0.875rem;
      text-align: center;
    }

    /* Chart */
    .chart-container {
      position: relative;
      margin: 1rem 0;
      background: var(--bg-secondary);
      border: 1px solid var(--border-primary);
      border-radius: 12px;
      padding: 1rem;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    canvas {
      max-width: 100%;
      border-radius: 8px;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .container {
        padding: 0.75rem;
      }
      
      .header-content {
        flex-direction: column;
        text-align: center;
        gap: 0.75rem;
      }
      
      .header-text h1 {
        font-size: 1.25rem;
      }
      
      .btn-group {
        justify-content: center;
      }
      
      .control {
        grid-template-columns: 1fr;
        text-align: center;
      }
      
      .tabs {
        flex-direction: column;
      }
      
      .tab {
        min-width: unset;
      }
    }

    /* Mathematical expressions */
    .math {
      font-family: 'Times New Roman', serif;
      font-style: italic;
      padding: 0.5rem 1rem;
      background: var(--bg-secondary);
      border-radius: 6px;
      margin: 0.5rem 0;
      font-size: 0.9rem;
      color: var(--text-secondary);
    }

    /* Details/Summary */
    details {
      background: var(--bg-secondary);
      border: 1px solid var(--border-primary);
      border-radius: 8px;
      padding: 1rem;
      margin: 0.5rem 0;
    }

    summary {
      cursor: pointer;
      font-weight: 600;
      color: var(--accent-secondary);
      margin-bottom: 0.5rem;
    }

    .footer-text {
      text-align: center;
      color: var(--text-muted);
      font-size: 0.875rem;
      margin-top: 2rem;
      padding: 1rem;
    }

    /* Loading states */
    .loading {
      opacity: 0.6;
      pointer-events: none;
    }

    /* Error states */
    .error {
      color: var(--accent-error);
      background: rgba(239, 68, 68, 0.1);
      padding: 0.5rem;
      border-radius: 6px;
      font-size: 0.875rem;
    }
  </style>
</head>
<body>
  <header>
    <div class="container">
      <div class="header-content">
        <div class="logo">AI</div>
        <div class="header-text">
          <h1>å³æ™‚æ•¸æ“šé è­¦æ¼”ç®—æ³•æ•™å­¸</h1>
          <div class="subtitle">Kalman Filterãƒ»Echo State Networkãƒ»Holt's Exponential Smoothingï½œForecasting Algorithms Demo é›™èªæ•™å­¸</div>
        </div>
      </div>
    </div>
  </header>

  <main class="container">
    <div class="main-grid">
      <!-- Chart Section -->
      <section class="card">
        <div class="tag-row">
          <span class="tag">ğŸ“± Mobile-ready</span>
          <span class="tag">âš¡ Real-time</span>
          <span class="tag">ğŸ§® Lightweight</span>
        </div>
        
        <h2>ğŸ¯ èª²ç¨‹å°è¦½ï½œOverview</h2>
        <p>é€™å€‹äº’å‹•å¼æ•™å­¸ç¤ºç¯„è‘—é‡æ–¼åœ¨ <strong>æ‰‹æ©Ÿï¼å¹³æ¿</strong> ä¸Šå¿«é€Ÿç†è§£ä¸‰ç¨®å¯ç·šä¸Šæ›´æ–°çš„è¼•é‡é æ¸¬æ¼”ç®—æ³•ã€‚æ¯å€‹æ¼”ç®—æ³•æä¾›ï¼š<strong>æ¦‚å¿µ</strong>ã€<strong>å…¬å¼</strong>ã€<strong>åƒæ•¸</strong>ã€<strong>å³æ™‚èª¿æ•´èˆ‡åœ–è¡¨</strong>ã€‚æœ¬æ•™æä½¿ç”¨è€…ä¸éœ€æ·±åšæ•¸å­¸èƒŒæ™¯ä¹Ÿèƒ½ä¸Šæ‰‹ã€‚</p>
        <p>This interactive tutorial is optimized for <strong>phones/tablets</strong> and introduces three <strong>incremental forecasting</strong> algorithms with <strong>concepts</strong>, <strong>equations</strong>, <strong>parameters</strong>, and <strong>live charts</strong>. Designed for non-math majors.</p>
        
        <div class="btn-group">
          <button class="btn btn-primary" id="btnAddNoise" title="æ–°å¢ä¸€ç­†è§€æ¸¬ä¸¦æ›´æ–°é æ¸¬ï½œAdd one observation and update forecasts">
            â• æ–°å¢ä¸€ç­†è³‡æ–™ Add Point
          </button>
          <button class="btn btn-secondary" id="btnStream">
            â–¶ï¸ é–‹å§‹/åœæ­¢ä¸²æµ Start/Stop
          </button>
          <button class="btn btn-warning" id="btnReset">
            â™»ï¸ é‡ç½® Reset
          </button>
        </div>
        
        <p style="font-size: 0.875rem; color: var(--text-muted); margin-bottom: 1rem;">
          æç¤º Tipï¼šã€Œæ–°å¢ä¸€ç­†è³‡æ–™ã€æœƒåŠ å…¥ä¸€å€‹æ–°è§€æ¸¬å€¼ä¸¦æŠŠä¸‰æ¢é æ¸¬ç·šå‘å‰æ¨ 5 é»é¡¯ç¤ºã€‚Data: synthetic (sine + trend + noise).
        </p>
        
        <div class="chart-container">
          <canvas id="mainChart"></canvas>
        </div>
      </section>

      <!-- Algorithm Controls -->
      <section class="card">
        <h2>ğŸ”¬ æ¼”ç®—æ³•åˆ‡æ›ï½œAlgorithm Tabs</h2>
        <div class="tabs">
          <button class="tab active" data-tab="kalman">â‘  å¡çˆ¾æ›¼æ¿¾æ³¢ Kalman</button>
          <button class="tab" data-tab="holt">â‘¡ Holt é›™æŒ‡æ•¸å¹³æ»‘</button>
          <button class="tab" data-tab="esn">â‘¢ Echo State Network</button>
        </div>

        <!-- Kalman Panel -->
        <div class="panel active" id="panel-kalman">
          <div class="panel-grid">
            <div>
              <h3>ğŸ’¡ æ¦‚å¿µï½œConcept</h3>
              <p>ç”¨æ–¼å«é›œè¨Šçš„å‹•æ…‹ç³»çµ±ä¼°æ¸¬ï¼šå‡è¨­çœŸå¯¦ç‹€æ…‹ <em>x</em> ä»¥ç°¡å–®æ¨¡å‹ï¼ˆæ­¤è™•ç”¨ã€Œéš¨æ©ŸéŠ€èµ°ã€ï¼‰æ¼”é€²ï¼Œé‡æ¸¬ <em>z</em> = <em>x</em> + é›œè¨Šã€‚å¡çˆ¾æ›¼æ¿¾æ³¢åœ¨æ¯æ¬¡æ–°è§€æ¸¬åˆ°ä¾†æ™‚ï¼Œ<strong>å…ˆé æ¸¬</strong>å†<strong>æ›´æ–°</strong>ï¼ŒåŒæ™‚è¼¸å‡ºä¸ç¢ºå®šåº¦ã€‚</p>
              <p>Best for noisy streams: predict state then correct with the new observation, also tracking uncertainty.</p>
              <details>
                <summary>ğŸ“ å…¬å¼ï½œEquations</summary>
                <div class="math">
                  Predict: xÌ‚â» = xÌ‚ + 0, Pâ» = P + Q<br/>
                  Update: K = Pâ»/(Pâ» + R), xÌ‚ = xÌ‚â» + K(z-xÌ‚â»), P = (1-K)Pâ»
                </div>
              </details>
            </div>
            <div>
              <h3>âš™ï¸ åƒæ•¸ï½œParameters</h3>
              <div class="control-group">
                <div class="control">
                  <label>éç¨‹é›œè¨Š Q<small>Process noise</small></label>
                  <input id="kfQ" type="range" min="0.001" max="0.5" step="0.001" value="0.02">
                  <input id="kfQn" type="number" step="0.001" value="0.02">
                </div>
                <div class="control">
                  <label>é‡æ¸¬é›œè¨Š R<small>Measurement noise</small></label>
                  <input id="kfR" type="range" min="0.001" max="1" step="0.001" value="0.05">
                  <input id="kfRn" type="number" step="0.001" value="0.05">
                </div>
                <div class="btn-group">
                  <button class="btn btn-primary" id="kfApply">å¥—ç”¨ Apply</button>
                  <button class="btn btn-secondary" id="kfRecalc">é‡æ–°è¨ˆç®— Recompute</button>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Holt Panel -->
        <div class="panel" id="panel-holt">
          <div class="panel-grid">
            <div>
              <h3>ğŸ’¡ æ¦‚å¿µï½œConcept</h3>
              <p>é›™æŒ‡æ•¸å¹³æ»‘æŠŠåºåˆ—æ‹†æˆ<strong>æ°´å¹³ L</strong>èˆ‡<strong>è¶¨å‹¢ B</strong>å…©éƒ¨åˆ†ï¼Œä½¿ç”¨æŒ‡æ•¸æ¬Šé‡æ›´æ–°ã€‚é©åˆ<strong>ç·šæ€§è¶¨å‹¢</strong>èˆ‡<strong>çŸ­æœŸé æ¸¬</strong>ï¼Œåƒæ•¸å°‘ã€è¨ˆç®—å¿«ã€‚</p>
              <p>Decomposes series into <strong>level</strong> and <strong>trend</strong> with exponential updates. Great for small data and short-term forecasting.</p>
              <details>
                <summary>ğŸ“ å…¬å¼ï½œEquations</summary>
                <div class="math">
                  L_t = Î± y_t + (1-Î±)(L_{t-1}+B_{t-1})<br/>
                  B_t = Î² (L_t-L_{t-1}) + (1-Î²)B_{t-1}<br/>
                  Forecast: Å·_{t+h} = L_t + h B_t
                </div>
              </details>
            </div>
            <div>
              <h3>âš™ï¸ åƒæ•¸ï½œParameters</h3>
              <div class="control-group">
                <div class="control">
                  <label>Î±ï¼ˆæ°´å¹³ï¼‰<small>Level smoothing</small></label>
                  <input id="holtA" type="range" min="0.01" max="0.9" step="0.01" value="0.4">
                  <input id="holtAn" type="number" step="0.01" value="0.4">
                </div>
                <div class="control">
                  <label>Î²ï¼ˆè¶¨å‹¢ï¼‰<small>Trend smoothing</small></label>
                  <input id="holtB" type="range" min="0.01" max="0.9" step="0.01" value="0.3">
                  <input id="holtBn" type="number" step="0.01" value="0.3">
                </div>
                <div class="control">
                  <label>å‰è¦–æ­¥æ•¸ h<small>Horizon (steps)</small></label>
                  <input id="holtH" type="range" min="1" max="12" step="1" value="5">
                  <input id="holtHn" type="number" step="1" value="5">
                </div>
                <div class="btn-group">
                  <button class="btn btn-primary" id="holtApply">å¥—ç”¨ Apply</button>
                  <button class="btn btn-secondary" id="holtRecalc">é‡æ–°è¨ˆç®— Recompute</button>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- ESN Panel -->
        <div class="panel" id="panel-esn">
          <div class="panel-grid">
            <div>
              <h3>ğŸ’¡ æ¦‚å¿µï½œConcept</h3>
              <p>ESN ä½¿ç”¨<strong>éš¨æ©Ÿå›ºå®š</strong>çš„ reservoirï¼ˆéš±å±¤ï¼‰ï¼Œåƒ…<strong>è¨“ç·´è¼¸å‡ºå±¤</strong>ã€‚æœ¬ç¤ºç¯„æ¡ç”¨<strong>RLSï¼ˆéè¿´æœ€å°å¹³æ–¹ï¼‰</strong>åšå¢é‡ ridge æ›´æ–°ï¼Œé©åˆåœ¨æ‰‹æ©Ÿä¸Šå¿«é€Ÿèª¿æ•´ã€‚</p>
              <p>Reservoir is random & fixed; only the readout is learned. We use <strong>Recursive Least Squares</strong> for online ridge updates.</p>
              <details>
                <summary>ğŸ“ å…¬å¼ï½œEquations (Sketch)</summary>
                <div class="math">
                  Reservoir: r_t = tanh(W_{res} r_{t-1} + W_{in} u_t + b)<br/>
                  RLS gain: k_t = P x_t /(1 + x_t^T P x_t)<br/>
                  Weights: W â† W + k_t (y_t - x_t^T W), P â† P - k_t x_t^T P
                </div>
              </details>
            </div>
            <div>
              <h3>âš™ï¸ åƒæ•¸ï½œParameters</h3>
              <div class="control-group">
                <div class="control">
                  <label>Reservoir å¤§å°<small>Size</small></label>
                  <input id="esnN" type="range" min="10" max="100" step="1" value="50">
                  <input id="esnNn" type="number" step="1" value="50">
                </div>
                <div class="control">
                  <label>å…‰è­œåŠå¾‘ Ï<small>Spectral radius</small></label>
                  <input id="esnRho" type="range" min="0.1" max="1.2" step="0.01" value="0.9">
                  <input id="esnRhon" type="number" step="0.01" value="0.9">
                </div>
                <div class="control">
                  <label>è¼¸å…¥ç¸®æ”¾<small>Input scale</small></label>
                  <input id="esnScale" type="range" min="0.1" max="2" step="0.01" value="0.5">
                  <input id="esnScalen" type="number" step="0.01" value="0.5">
                </div>
                <div class="control">
                  <label>Ridge Î»<small>Regularization</small></label>
                  <input id="esnLam" type="range" min="0.001" max="1" step="0.001" value="0.01">
                  <input id="esnLamn" type="number" step="0.001" value="0.01">
                </div>
                <div class="btn-group">
                  <button class="btn btn-primary" id="esnApply">å¥—ç”¨ Apply</button>
                  <button class="btn btn-secondary" id="esnReinit">é‡æ–°åˆå§‹åŒ– Reinit</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>
    </div>

    <!-- Usage Instructions -->
    <section class="card">
      <h2>ğŸ“– ä½¿ç”¨æ–¹å¼ï½œHow to Use</h2>
      <div class="panel-grid">
        <div>
          <h3>ä¸­æ–‡èªªæ˜</h3>
          <ol style="color: var(--text-secondary); line-height: 1.8;">
            <li>æŒ‰ã€Œæ–°å¢ä¸€ç­†è³‡æ–™ã€æˆ–å•Ÿå‹•ã€Œä¸²æµã€é€æ­¥ç”¢ç”Ÿè§€æ¸¬å€¼ã€‚</li>
            <li>åˆ‡æ›ä¸Šæ–¹åˆ†é ï¼Œèª¿æ•´åƒæ•¸ä¸¦è§€å¯Ÿé æ¸¬æ›²ç·šèˆ‡èª¤å·®ã€‚</li>
            <li>é•·æŒ‰åœ–è¡¨å¯æ‹–å‹•æ™‚é–“è»¸ï¼›å°è¢å¹•ä¸‹å…ƒä»¶å°‡è‡ªå‹•æ›è¡Œã€‚</li>
          </ol>
        </div>
        <div>
          <h3>English Instructions</h3>
          <ol style="color: var(--text-secondary); line-height: 1.8;">
            <li>Click <strong>Add Point</strong> or start <strong>Stream</strong> to feed observations.</li>
            <li>Switch tabs, tune parameters, and watch predictions and errors update.</li>
            <li>On phones, layout wraps automatically; long-press chart to pan.</li>
          </ol>
        </div>
      </div>
    </section>

    <div class="footer-text">
      Â© æ•™å­¸ç¤ºç¯„ç”¨é€”ï½œFor educational demo only
    </div>
  </main>

  <script>
    // ===== Utilities =====
    const clamp = (v, min, max) => Math.max(min, Math.min(max, Number(v)));
    
    // Improved Box-Muller transform for normal distribution
    let hasSpareGaussian = false;
    let spareGaussian = 0;
    
    const randn = () => {
      if (hasSpareGaussian) {
        hasSpareGaussian = false;
        return spareGaussian;
      }
      
      hasSpareGaussian = true;
      const u = Math.random();
      const v = Math.random();
      const mag = 0.15 * Math.sqrt(-2 * Math.log(u));
      spareGaussian = mag * Math.cos(2 * Math.PI * v);
      return mag * Math.sin(2 * Math.PI * v);
    };

    // ===== Synthetic Data Stream =====
    const data = { t: [], y: [] };
    let t = 0;
    let streaming = false;
    let streamTimer = null;
    
    function genPoint() {
      t += 1;
      // More interesting synthetic data: sine wave + linear trend + noise
      const base = 0.6 * Math.sin(t / 8) + 0.03 * t + 2;
      const y = base + randn();
      data.t.push(t);
      data.y.push(y);
      return { t, y };
    }

    // ===== Chart Setup =====
    const ctx = document.getElementById('mainChart');
    const chartColors = {
      observed: '#10b981',    // Green
      kalman: '#3b82f6',      // Blue  
      holt: '#f59e0b',        // Amber
      esn: '#ef4444'          // Red
    };
    
    const chart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: [],
        datasets: [
          {
            label: 'è§€æ¸¬ Observed',
            data: [],
            borderColor: chartColors.observed,
            backgroundColor: chartColors.observed + '20',
            tension: 0.3,
            pointRadius: 3,
            pointHoverRadius: 5,
            borderWidth: 2.5,
            fill: false
          },
          {
            label: 'Kalman é æ¸¬ (t+5)',
            data: [],
            borderColor: chartColors.kalman,
            backgroundColor: chartColors.kalman + '20',
            tension: 0.3,
            pointRadius: 0,
            borderWidth: 2,
            borderDash: [8, 4],
            fill: false
          },
          {
            label: 'Holt é æ¸¬ (t+5)',
            data: [],
            borderColor: chartColors.holt,
            backgroundColor: chartColors.holt + '20',
            tension: 0.3,
            pointRadius: 0,
            borderWidth: 2,
            borderDash: [8, 4],
            fill: false
          },
          {
            label: 'ESN é æ¸¬ (t+5)',
            data: [],
            borderColor: chartColors.esn,
            backgroundColor: chartColors.esn + '20',
            tension: 0.3,
            pointRadius: 0,
            borderWidth: 2,
            borderDash: [8, 4],
            fill: false
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: true,
        aspectRatio: window.innerWidth < 768 ? 1.2 : 2,
        animation: {
          duration: 300,
          easing: 'easeInOutQuart'
        },
        layout: {
          padding: {
            left: 8,
            right: 8,
            top: 8,
            bottom: 8
          }
        },
        scales: {
          x: {
            grid: {
              color: 'rgba(75, 85, 99, 0.3)',
              lineWidth: 1
            },
            ticks: {
              color: '#d1d5db',
              font: {
                size: 12,
                weight: '500'
              },
              maxTicksLimit: window.innerWidth < 768 ? 6 : 10
            },
            title: {
              display: true,
              text: 'Time Steps',
              color: '#9ca3af',
              font: {
                size: 14,
                weight: '600'
              }
            }
          },
          y: {
            grid: {
              color: 'rgba(75, 85, 99, 0.3)',
              lineWidth: 1
            },
            ticks: {
              color: '#d1d5db',
              font: {
                size: 12,
                weight: '500'
              }
            },
            title: {
              display: true,
              text: 'Value',
              color: '#9ca3af',
              font: {
                size: 14,
                weight: '600'
              }
            }
          }
        },
        plugins: {
          legend: {
            position: 'top',
            labels: {
              color: '#d1d5db',
              font: {
                size: 13,
                weight: '600'
              },
              padding: 15,
              usePointStyle: true,
              pointStyle: 'line'
            }
          },
          tooltip: {
            backgroundColor: 'rgba(31, 41, 55, 0.95)',
            titleColor: '#f9fafb',
            bodyColor: '#d1d5db',
            borderColor: 'rgba(75, 85, 99, 0.5)',
            borderWidth: 1,
            cornerRadius: 8,
            displayColors: true,
            titleFont: {
              size: 14,
              weight: '600'
            },
            bodyFont: {
              size: 13
            }
          }
        },
        interaction: {
          intersect: false,
          mode: 'index'
        }
      }
    });

    const FORECAST_OFFSET = 5;

    function ensureLabelsUpTo(targetT) {
      while (chart.data.labels.length < targetT) {
        chart.data.labels.push(chart.data.labels.length + 1);
      }
    }

    function pushObserved(y) {
      chart.data.labels.push(t);
      chart.data.datasets[0].data.push(y);
    }

    function setForecastAt(offsetT, kfVal, holtVal, esnVal) {
      ensureLabelsUpTo(offsetT);
      const idx = offsetT - 1;
      const datasets = chart.data.datasets;
      
      // Extend arrays with nulls if needed
      const needLen = chart.data.labels.length;
      for (let i = 1; i < datasets.length; i++) {
        while (datasets[i].data.length < needLen) {
          datasets[i].data.push(null);
        }
      }
      
      if (idx >= 0 && idx < needLen) {
        datasets[1].data[idx] = kfVal;
        datasets[2].data[idx] = holtVal;
        datasets[3].data[idx] = esnVal;
      }
    }

    function resetAll() {
      data.t = [];
      data.y = [];
      t = 0;
      streaming = false;
      
      if (streamTimer) {
        clearInterval(streamTimer);
        streamTimer = null;
      }
      
      chart.data.labels = [];
      chart.data.datasets.forEach(d => d.data = []);
      chart.update();
      
      // Reset algorithms
      KF.reset();
      HOLT.reset();
      ESN.reset();
      
      updateStreamButton();
    }

    // ===== Kalman Filter (1D Random Walk) =====
    const KF = (function() {
      let x = 0, P = 1, Q = 0.02, R = 0.05, initialized = false;
      
      return {
        set(q, r) {
          Q = clamp(q, 0.001, 1);
          R = clamp(r, 0.001, 1);
        },
        
        step(z) {
          if (!initialized) {
            x = z;
            P = 1;
            initialized = true;
          }
          
          // Predict step
          // For random walk: x_k|k-1 = x_k-1|k-1
          // P_k|k-1 = P_k-1|k-1 + Q
          P = P + Q;
          
          // Update step
          const K = P / (P + R); // Kalman gain
          x = x + K * (z - x);   // State update
          P = (1 - K) * P;       // Covariance update
          
          return x;
        },
        
        predict(steps = 1) {
          return x; // For random walk, prediction is current state
        },
        
        reset() {
          x = 0;
          P = 1;
          initialized = false;
        },
        
        getState() {
          return { x, P, Q, R };
        }
      };
    })();

    // ===== Holt's Linear Exponential Smoothing =====
    const HOLT = (function() {
      let alpha = 0.4, beta = 0.3, L = 0, B = 0, initialized = false, horizon = 5;
      
      return {
        set(a, b, h) {
          alpha = clamp(a, 0.01, 0.99);
          beta = clamp(b, 0.01, 0.99);
          horizon = Math.max(1, parseInt(h));
        },
        
        step(y) {
          if (!initialized) {
            L = y;
            B = 0;
            initialized = true;
            return y;
          }
          
          const prevL = L;
          L = alpha * y + (1 - alpha) * (L + B);
          B = beta * (L - prevL) + (1 - beta) * B;
          
          return L + B; // One-step ahead forecast
        },
        
        forecast(h = null) {
          const steps = h !== null ? h : horizon;
          return L + steps * B;
        },
        
        reset() {
          initialized = false;
          L = 0;
          B = 0;
        },
        
        getState() {
          return { alpha, beta, L, B, horizon };
        }
      };
    })();

    // ===== Echo State Network (Improved Implementation) =====
    const ESN = (function() {
      let N = 50, rho = 0.9, inputScale = 0.5, lambda = 0.01;
      let Wres, Win, r, Wout, P;
      let initialized = false;

      function createMatrix(rows, cols, scale = 1) {
        const matrix = new Array(rows);
        for (let i = 0; i < rows; i++) {
          matrix[i] = new Array(cols);
          for (let j = 0; j < cols; j++) {
            matrix[i][j] = (Math.random() * 2 - 1) * scale;
          }
        }
        return matrix;
      }

      function matrixVectorMultiply(matrix, vector) {
        const result = new Array(matrix.length);
        for (let i = 0; i < matrix.length; i++) {
          result[i] = 0;
          for (let j = 0; j < vector.length; j++) {
            result[i] += matrix[i][j] * vector[j];
          }
        }
        return result;
      }

      function scaleToSpectralRadius(matrix, targetRho) {
        // Simple approximation using power iteration
        let v = new Array(matrix.length).fill(0).map(() => Math.random());
        
        // Normalize v
        let norm = Math.sqrt(v.reduce((sum, x) => sum + x * x, 0));
        v = v.map(x => x / norm);
        
        // Power iteration
        for (let iter = 0; iter < 20; iter++) {
          v = matrixVectorMultiply(matrix, v);
          norm = Math.sqrt(v.reduce((sum, x) => sum + x * x, 0));
          if (norm > 1e-12) {
            v = v.map(x => x / norm);
          }
        }
        
        // Estimate spectral radius
        const Av = matrixVectorMultiply(matrix, v);
        const spectralRadius = Math.abs(v.reduce((sum, val, i) => sum + val * Av[i], 0));
        
        // Scale matrix
        const scale = targetRho / (spectralRadius || 1);
        for (let i = 0; i < matrix.length; i++) {
          for (let j = 0; j < matrix[i].length; j++) {
            matrix[i][j] *= scale;
          }
        }
      }

      function init() {
        try {
          // Create reservoir weight matrix
          Wres = createMatrix(N, N, 1);
          scaleToSpectralRadius(Wres, rho);
          
          // Create input weight matrix
          Win = new Array(N).fill(0).map(() => (Math.random() * 2 - 1) * inputScale);
          
          // Initialize reservoir state
          r = new Array(N).fill(0);
          
          // Initialize output weights
          Wout = new Array(N).fill(0);
          
          // Initialize RLS inverse covariance matrix
          P = createMatrix(N, N, 0);
          const invLambda = 1 / lambda;
          for (let i = 0; i < N; i++) {
            P[i][i] = invLambda;
          }
          
          initialized = true;
        } catch (error) {
          console.error('ESN initialization error:', error);
          initialized = false;
        }
      }

      function step(u, yTarget) {
        if (!initialized) init();
        if (!initialized) return 0;
        
        try {
          // Update reservoir state: r = tanh(Wres * r + Win * u)
          const newR = new Array(N);
          for (let i = 0; i < N; i++) {
            let sum = Win[i] * u;
            for (let j = 0; j < N; j++) {
              sum += Wres[i][j] * r[j];
            }
            newR[i] = Math.tanh(sum);
          }
          r = newR;
          
          // Compute current output
          let yHat = 0;
          for (let i = 0; i < N; i++) {
            yHat += Wout[i] * r[i];
          }
          
          // RLS update
          if (yTarget !== undefined && !isNaN(yTarget)) {
            // Compute P * r
            const Pr = new Array(N);
            for (let i = 0; i < N; i++) {
              Pr[i] = 0;
              for (let j = 0; j < N; j++) {
                Pr[i] += P[i][j] * r[j];
              }
            }
            
            // Compute denominator: 1 + r^T * P * r
            let denom = 1;
            for (let i = 0; i < N; i++) {
              denom += r[i] * Pr[i];
            }
            
            if (Math.abs(denom) > 1e-12) {
              // Compute gain: k = P * r / denom
              const gain = Pr.map(x => x / denom);
              
              // Update weights: W = W + k * error
              const error = yTarget - yHat;
              for (let i = 0; i < N; i++) {
                Wout[i] += gain[i] * error;
              }
              
              // Update P: P = P - k * r^T * P
              const rTP = new Array(N);
              for (let j = 0; j < N; j++) {
                rTP[j] = 0;
                for (let i = 0; i < N; i++) {
                  rTP[j] += r[i] * P[i][j];
                }
              }
              
              for (let i = 0; i < N; i++) {
                for (let j = 0; j < N; j++) {
                  P[i][j] -= gain[i] * rTP[j];
                }
              }
            }
          }
          
          return yHat;
        } catch (error) {
          console.error('ESN step error:', error);
          return 0;
        }
      }

      return {
        set(n, rhoVal, scale, lam) {
          N = Math.max(10, Math.min(100, parseInt(n)));
          rho = clamp(rhoVal, 0.1, 1.5);
          inputScale = clamp(scale, 0.01, 2);
          lambda = clamp(lam, 0.001, 1);
        },
        
        step,
        
        reset() {
          initialized = false;
        },
        
        init,
        
        getState() {
          return { N, rho, inputScale, lambda, initialized };
        }
      };
    })();

    // ===== UI Controls =====
    function syncRangeNumber(rangeSelector, numberSelector) {
      const range = document.querySelector(rangeSelector);
      const number = document.querySelector(numberSelector);
      
      if (!range || !number) return;
      
      const updateNumber = () => number.value = range.value;
      const updateRange = () => range.value = number.value;
      
      range.addEventListener('input', updateNumber);
      number.addEventListener('input', updateRange);
      
      return { range, number };
    }

    // Sync controls
    syncRangeNumber('#kfQ', '#kfQn');
    syncRangeNumber('#kfR', '#kfRn');
    syncRangeNumber('#holtA', '#holtAn');
    syncRangeNumber('#holtB', '#holtBn');
    syncRangeNumber('#holtH', '#holtHn');
    syncRangeNumber('#esnN', '#esnNn');
    syncRangeNumber('#esnRho', '#esnRhon');
    syncRangeNumber('#esnScale', '#esnScalen');
    syncRangeNumber('#esnLam', '#esnLamn');

    // Button handlers
    document.getElementById('kfApply').addEventListener('click', () => {
      const Q = document.getElementById('kfQ').value;
      const R = document.getElementById('kfR').value;
      KF.set(Q, R);
    });

    document.getElementById('kfRecalc').addEventListener('click', recomputeAll);

    document.getElementById('holtApply').addEventListener('click', () => {
      const alpha = document.getElementById('holtA').value;
      const beta = document.getElementById('holtB').value;
      const horizon = document.getElementById('holtH').value;
      HOLT.set(alpha, beta, horizon);
    });

    document.getElementById('holtRecalc').addEventListener('click', recomputeAll);

    document.getElementById('esnApply').addEventListener('click', () => {
      const n = document.getElementById('esnN').value;
      const rho = document.getElementById('esnRho').value;
      const scale = document.getElementById('esnScale').value;
      const lambda = document.getElementById('esnLam').value;
      ESN.set(n, rho, scale, lambda);
    });

    document.getElementById('esnReinit').addEventListener('click', () => {
      ESN.reset();
      ESN.init();
      recomputeAll();
    });

    // Tab switching
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        // Remove active from all tabs and panels
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
        
        // Add active to clicked tab and corresponding panel
        tab.classList.add('active');
        const targetPanel = document.getElementById('panel-' + tab.dataset.tab);
        if (targetPanel) {
          targetPanel.classList.add('active');
        }
      });
    });

    // Main action buttons
    function updateStreamButton() {
      const btn = document.getElementById('btnStream');
      btn.textContent = streaming ? 'â¸ï¸ æš«åœ Pause' : 'â–¶ï¸ é–‹å§‹ä¸²æµ Start';
      btn.classList.toggle('btn-warning', streaming);
    }

    document.getElementById('btnAddNoise').addEventListener('click', () => {
      const btn = document.getElementById('btnAddNoise');
      btn.style.transform = 'scale(0.95)';
      setTimeout(() => btn.style.transform = '', 150);
      
      const { y } = genPoint();
      streamStep(y);
    });

    document.getElementById('btnStream').addEventListener('click', () => {
      streaming = !streaming;
      
      if (streaming) {
        streamTimer = setInterval(() => {
          const { y } = genPoint();
          streamStep(y);
        }, 400);
      } else {
        if (streamTimer) {
          clearInterval(streamTimer);
          streamTimer = null;
        }
      }
      
      updateStreamButton();
    });

    document.getElementById('btnReset').addEventListener('click', resetAll);

    // Core streaming function
    function streamStep(y) {
      try {
        // Process through all algorithms
        const kfPred = KF.step(y);
        const holtCurrent = HOLT.step(y);
        const holtForecast = HOLT.forecast(FORECAST_OFFSET);
        const esnPred = ESN.step(y, y); // Teacher forcing
        
        // Update chart
        pushObserved(y);
        setForecastAt(t + FORECAST_OFFSET, kfPred, holtForecast, esnPred);
        
        chart.update('none'); // No animation for real-time updates
        
      } catch (error) {
        console.error('Error in streamStep:', error);
      }
    }

    function recomputeAll() {
      if (data.y.length === 0) return;
      
      // Store current data
      const savedY = [...data.y];
      const savedT = t;
      
      // Reset everything
      resetAll();
      
      // Reprocess all data
      for (let i = 0; i < savedY.length; i++) {
        t = i + 1;
        const y = savedY[i];
        
        const kfPred = KF.step(y);
        const holtCurrent = HOLT.step(y);
        const holtForecast = HOLT.forecast(FORECAST_OFFSET);
        const esnPred = ESN.step(y, y);
        
        pushObserved(y);
        setForecastAt(t + FORECAST_OFFSET, kfPred, holtForecast, esnPred);
      }
      
      chart.update();
    }

    // Initialize algorithms with default parameters
    function initializeAlgorithms() {
      KF.set(
        document.getElementById('kfQ').value,
        document.getElementById('kfR').value
      );
      
      HOLT.set(
        document.getElementById('holtA').value,
        document.getElementById('holtB').value,
        document.getElementById('holtH').value
      );
      
      ESN.set(
        document.getElementById('esnN').value,
        document.getElementById('esnRho').value,
        document.getElementById('esnScale').value,
        document.getElementById('esnLam').value
      );
      
      ESN.init();
    }

    // Handle window resize for responsive chart
    window.addEventListener('resize', () => {
      chart.options.aspectRatio = window.innerWidth < 768 ? 1.2 : 2;
      chart.options.scales.x.ticks.maxTicksLimit = window.innerWidth < 768 ? 6 : 10;
      chart.resize();
    });

    // Initialize everything
    document.addEventListener('DOMContentLoaded', () => {
      initializeAlgorithms();
      updateStreamButton();
    });

    // Initialize on load
    initializeAlgorithms();
    updateStreamButton();
  </script>
</body>
</html>